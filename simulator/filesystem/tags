!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADDRESS	types.h	/^typedef int ADDRESS; $/;"	t
AMOUNT_OF_ADDRESS_PER_BLOCK	types.h	46;"	d
AMOUNT_OF_ALLBLOCK	types.h	72;"	d
AMOUNT_OF_BLOCK_FOR_TABLE_OF_DATABLOCK	types.h	67;"	d
AMOUNT_OF_BLOCK_FOR_TABLE_OF_INODE	types.h	63;"	d
AMOUNT_OF_DATABLOCK	types.h	41;"	d
AMOUNT_OF_DATABLOCK_FOR_INODE	types.h	76;"	d
AMOUNT_OF_DIRENTRY_PER_BLOCK	types.h	51;"	d
AMOUNT_OF_GROUP_PER_BLOCK	types.h	59;"	d
AMOUNT_OF_INODE	types.h	37;"	d
AMOUNT_OF_USER_PER_BLOCK	types.h	55;"	d
BLOCKSIZE	types.h	33;"	d
BUFSIZE	_test/_types.h	22;"	d
CC	Makefile	/^CC = gcc $/;"	m
CFLAG	Makefile	/^CFLAG = $/;"	m
DIRENTRY	types.h	/^} DIRENTRY; $/;"	t	typeref:struct:__anon3
EXECUTABLE	Makefile	/^EXECUTABLE = test.out$/;"	m
FULL_PERMISSION	fs.h	25;"	d
GROUP	types.h	/^} GROUP; $/;"	t	typeref:struct:__anon5
INODE	types.h	/^} INODE; $/;"	t	typeref:struct:__anon2
PartitionTable	types.h	/^} PartitionTable; $/;"	t	typeref:struct:__anon4
SPACE_OF_ALL_INODE	types.h	80;"	d
TA	_test/_types.h	/^} TA; $/;"	t	typeref:struct:__anon1
UMASK_OF_DIR	fs.h	27;"	d
UMASK_OF_FILE	fs.h	26;"	d
USER	types.h	/^} USER; $/;"	t	typeref:struct:__anon6
_types_INC	_test/_types.h	20;"	d
accessTime	types.h	/^  time_t accessTime; \/\/ 最近访问的时间$/;"	m	struct:__anon2
addDIRENTRY	fs.c	/^addDIRENTRY(DIRENTRY newEntry) {$/;"	f
buf	_test/_types.h	/^  char buf[BUFSIZE]; $/;"	m	struct:__anon1
compareString	utils.c	/^compareString(char *strA, $/;"	f
createGrpFile	fs.c	/^createGrpFile() {$/;"	f
createPasswdFile	fs.c	/^createPasswdFile() {$/;"	f
createRootDirectory	fs.c	/^createRootDirectory() {$/;"	f
createTime	types.h	/^  time_t createTime; \/\/ 创建的时间 $/;"	m	struct:__anon2
currentUser	test.c	/^USER currentUser; $/;"	v
dirEntries	test.c	/^DIRENTRY dirEntries[AMOUNT_OF_DIRENTRY_PER_BLOCK]; $/;"	v
fileName	types.h	/^  char fileName[28]; $/;"	m	struct:__anon3
findAvailableDataBlock	fs.c	/^findAvailableDataBlock() {$/;"	f
findAvailableINODE	fs.c	/^findAvailableINODE() {$/;"	f
formatFS	fs.c	/^formatFS() {$/;"	f
fp	test.c	/^FILE *fp; $/;"	v
fs_INC	fs.h	21;"	d
genEmptyINODE	fs.c	/^genEmptyINODE() {$/;"	f
getActualAddressOfDataBlock	fs.c	/^getActualAddressOfDataBlock(int index) {$/;"	f
getActualAddressOfINODE	fs.c	/^getActualAddressOfINODE(int index) {$/;"	f
getDefaultPermission	fs.c	/^getDefaultPermission(int type) {$/;"	f
gid	types.h	/^  char gid; $/;"	m	struct:__anon5
gid	types.h	/^  char gid; $/;"	m	struct:__anon6
headAddress	types.h	/^  ADDRESS headAddress;  \/\/ 首数据块地址$/;"	m	struct:__anon2
inodeNum	types.h	/^  int inodeNum; $/;"	m	struct:__anon3
links	types.h	/^  int links; \/\/ 链接数$/;"	m	struct:__anon2
loadINODE	fs.c	/^loadINODE(int inodeNum) {$/;"	f
loadPartitionTable	fs.c	/^loadPartitionTable() {$/;"	f
main	_test/_array.c	/^main(int argc, $/;"	f
main	_test/_read.c	/^main(int argc, $/;"	f
main	_test/_writeStruct.c	/^main(int argc, $/;"	f
main	test.c	/^main(int argc, $/;"	f
name	types.h	/^  char name[14]; $/;"	m	struct:__anon6
name	types.h	/^  char name[15]; $/;"	m	struct:__anon5
nodeIndex	_test/_types.h	/^  int nodeIndex; $/;"	m	struct:__anon1
openFSForRead	fs.c	/^openFSForRead() {$/;"	f
openFSForWrite	fs.c	/^openFSForWrite() {$/;"	f
partitionTable	test.c	/^PartitionTable *partitionTable; $/;"	v
permission	types.h	/^  int permission; \/\/ 权限$/;"	m	struct:__anon2
restorePartitionTable	fs.c	/^restorePartitionTable() {$/;"	f
size	types.h	/^  int size;   \/\/ 文件大小, 如果大于1个block，则表示直接寻址 $/;"	m	struct:__anon2
strFailure	types.h	25;"	d
strSuccess	types.h	26;"	d
tableDataBlock	types.h	/^  char tableDataBlock[AMOUNT_OF_DATABLOCK]; $/;"	m	struct:__anon4
tableINODE	types.h	/^  char tableINODE[AMOUNT_OF_INODE]; $/;"	m	struct:__anon4
types_INC	types.h	21;"	d
uid	types.h	/^  char uid; $/;"	m	struct:__anon6
utils_INC	utils.h	20;"	d
vfsPath	test.c	/^char *vfsPath = "vfs"; $/;"	v
workingDir	test.c	/^DIRENTRY workingDir; $/;"	v
workingDirINODE	test.c	/^INODE workingDirINODE; $/;"	v
writeBackINODE	fs.c	/^writeBackINODE(int index, $/;"	f
